<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <!-- ===================================================== -->
    <!-- ================ Customer Services ================== -->
    <!-- =====================================================-->
    <!-- Contents     
        =======   Login/Register =========
        [1] register#Customer.........[OK]
        [2] login#Customer............[OK]
        [3] logout#Customer...........[OK]
        [4] postLogin#Customer........[OK]
        =======   Customer Account =======
        (implements interface#CustomerInfo)
        [5] get#CustomerInfo..........[OK]
        [6] update#Customer...........[OK]
        [7] update#CustomerPassword...[OK]
        ======= Forgot/Reset Passw =======
        [8] reset#Password............[OK]
        [9] set#CustomerPassword......[OK]
        ======= Shipping Addresses =======
        (implements interface#CustomerAddressInfo)
        [10] get#ShippingAddresses.....[OK]
        [11] create#ShippingAddress....[OK]
        [12] update#ShippingAddress....[OK]
        [13] delete#ShippingAddress....[OK]
        ======= Customer Order ==========
        [14] get#CustomerOrders........[OK]
    -->

    <!-- TODO
    [1] handle pagination in get#CustomerOrders...Done 
    -->
    <service verb="interface" noun="CustomerInfo">
        <out-parameters>
            <parameter name="username" />
            <parameter name="firstName" />
            <parameter name="middleName" />
            <parameter name="lastName" />
            <parameter name="emailAddress" />
            <!-- <parameter name="telecomNumber" /> -->
            <parameter name="gender" />
        </out-parameters>
    </service>
    <service verb="interface" noun="CustomerAddressInfo">
        <out-parameters>
            <parameter name="postalAddressList" type="List">
                <parameter name="addressInfo" type="Map">
                    <parameter name="addressId" />
                    <parameter name="alias" />
                    <parameter name="address1" />
                    <parameter name="address2" />
                    <parameter name="postalCode" />
                    <parameter name="city" />
                    <parameter name="cityId" />
                    <parameter name="stateId" />
                    <parameter name="countryId" />
                    <parameter name="cityName" />
                    <parameter name="stateName" />
                    <parameter name="countryName" />
                    <parameter name="phone" type="Map">
                        <parameter name="countryCode" />
                        <parameter name="areaCode" />
                        <parameter name="contactNumber" />
                    </parameter>
                </parameter>
            </parameter>
        </out-parameters>
    </service>

    <!-- Login and Register for eCommerce -->
    <service verb="register" noun="Customer" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="productStoreId" />
            <parameter name="firstName" required="true" />
            <parameter name="middleName" />
            <parameter name="lastName" required="true" />
            <parameter name="emailAddress" required="true">
                <text-email />
            </parameter>
            <parameter name="username" default="emailAddress" />
            <parameter name="password" required="true" />
            <parameter name="passwordVerify" default="password" />
            <parameter name="locale" />
            <parameter name="timeZone" />
        </in-parameters>
        <out-parameters>
            <parameter name="emailContactMechId" />
            <parameter name="moquiSessionToken" />
            <parameter name="customerInfo" type="Map" />
        </out-parameters>
        <actions>
            <!-- TODO: TEMP FIX THIS AFTER VSF API CLIENT UPDATE -->
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
            <set field="ownerPartyId" from="productStore?.organizationPartyId?:'POPC_DEFAULT'"/>
            <!-- create account and login -->
            <service-call name="mantle.party.PartyServices.create#Account" in-map="context + [newPassword:password, newPasswordVerify:passwordVerify, roleTypeId:'Customer', ownerPartyId:ownerPartyId, loginAfterCreate:true]" out-map="customerInfo" />
            <service-call name="mantle.party.PartyServices.set#PartyClassification" in-map="[partyId:customerInfo.partyId, partyClassificationId:'CustConsumer']" />

            <if condition="ec.user.userAccount != null">
                <set field="customerPartyId" from="ec.user.userAccount.partyId" />
                <!-- NOTE: use the web session for attributes such as cartOrderId for security; this won't work in a stateless mode or outside a web session -->
                <set field="sessionAttributes" from="ec.web.sessionAttributes" />
                <set field="sessionAttributes.customerPartyId" from="customerPartyId" />
                <set field="cartOrderId" from="sessionAttributes.cartOrderId" />

                <!-- if a cartOrderId is in the session set the logged in user as the customer -->
                <if condition="cartOrderId &amp;&amp; customerPartyId">
                    <!-- NOTE: make sure orderHeader has no enteredByPartyId, ie only find those with null to avoid order takeover -->
                    <entity-find-one entity-name="OrderHeader" value-field="orderHeader" auto-field-map="[orderId:cartOrderId]" />
                    <if condition="!orderHeader.enteredByPartyId">
                        <set field="orderHeader.enteredByPartyId" from="customerPartyId" />
                        <entity-update value-field="orderHeader" />

                        <!-- NOTE: make sure cartOrder has no customerPartyId, ie only find those with null to avoid order takeover -->
                        <!-- TODO: Handle multiple OrderParts -->
                        <entity-find entity-name="OrderPart" list="orderPartList">
                            <econdition field-name="orderId" from="cartOrderId" />
                            <econdition field-name="customerPartyId" operator="is-null" />
                        </entity-find>
                        <if condition="orderPartList">
                            <set field="orderPart" from="orderPartList[0]" />
                            <set field="orderPart.customerPartyId" from="customerPartyId" />
                            <entity-update value-field="orderPart" />
                        </if>
                    </if>
                </if>

                <set field="moquiSessionToken" from="ec.web.sessionToken" />

                <!-- get customer info for convenience -->
                <service-call name="vsf.CustomerServices.get#CustomerInfo" in-map="context" out-map="customerInfo" />
            </if>
        </actions>
    </service>

    <service verb="login" noun="Customer">
        <in-parameters>
            <parameter name="username" required="true" />
            <parameter name="password" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="moquiSessionToken" />
            <parameter name="customerInfo" type="Map" />
            <parameter name="forcePasswordChange" />
        </out-parameters>
        <actions>
            <set field="forcePasswordChange" value="false" type="Boolean" />
            <entity-find-one entity-name="moqui.security.UserAccount" value-field="userAccount" cache="false">
                <field-map field-name="username" />
            </entity-find-one>
            <if condition="!userAccount">
                <entity-find-one entity-name="moqui.security.UserAccount" value-field="userAccount" cache="false">
                    <field-map field-name="emailAddress" from="username" />
                </entity-find-one>
            </if>
            <if condition="userAccount?.requirePasswordChange == 'Y'">
                <set field="forcePasswordChange" value="true" type="Boolean" />
                <return />
            </if>
            <script>ec.user.loginUser(userAccount?.username?:username, password)</script>
            <!-- update locale, if cookie is available -->
            <service-call name="vsf.UtilServices.get#LocaleFromCookies" out-map="context" />
            <service-call name="vsf.CustomerServices.postLogin#Customer" in-map="context" out-map="context" />
            <service-call name="mantle.party.PartyServices.set#PartyClassification" in-map="[partyId:userAccount.partyId, partyClassificationId:'CustConsumer']" />
        </actions>
    </service>

    <service verb="logout" noun="Customer" authenticate="anonymous-all">
        <actions>
            <script>ec.user.logoutUser()</script>
        </actions>
    </service>

    <service verb="postLogin" noun="Customer">
        <out-parameters>
            <parameter name="moquiSessionToken" />
            <parameter name="customerInfo" type="Map" />
        </out-parameters>
        <actions>
            <if condition="ec.user.userAccount != null">
                <set field="customerPartyId" from="ec.user.userAccount.partyId" />
                <!-- NOTE: use the web session for attributes such as cartOrderId for security; this won't work in a stateless mode or outside a web session -->
                <set field="sessionAttributes" from="ec.web.sessionAttributes" />
                <set field="sessionAttributes.customerPartyId" from="customerPartyId" />
                <set field="cartOrderId" from="ec.web.sessionAttributes.cartOrderId" />

                <!-- see if there is an open order for user and get that ID into session -->
                <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrderList">
                    <econdition field-name="statusId" value="OrderOpen" />
                    <econdition field-name="customerPartyId" />
                    <select-field field-name="orderId" />
                    <select-field field-name="orderPartSeqId" />
                    <order-by field-name="-entryDate" /> <!-- get most recent open order -->
                </entity-find>
                <if condition="existingOrderList">
                    <then>
                        <if condition="cartOrderId">
                            <!-- if a cartOrderId is in the session, merge its items into the existing order -->
                            <service-call name="mantle.order.OrderServices.merge#OrderItems" in-map="[orderId:existingOrderList[0].orderId, fromOrderId:cartOrderId]" />
                        </if>
                        <!-- whether there was one in the session or not always set the existing orderId there -->
                        <set field="sessionAttributes.cartOrderId" from="existingOrderList[0].orderId" />
                    </then>
                    <else>
                        <!-- no existing open order, if a cartOrderId is in the session set the logged in user as the customer -->
                        <if condition="cartOrderId">
                            <!-- NOTE: make sure cartOrder has no customerPartyId, ie only find those with null to avoid order takeover -->
                            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                                <econdition field-name="orderId" from="cartOrderId" />
                                <econdition field-name="customerPartyId" operator="is-null" />
                            </entity-find>
                            <if condition="orderPartList">
                                <set field="orderPart" from="orderPartList[0]" />
                                <set field="orderPart.customerPartyId" from="customerPartyId" />
                                <entity-update value-field="orderPart" />
                            </if>
                        </if>
                    </else>
                </if>

                <set field="moquiSessionToken" from="ec.web.sessionToken" />

                <!-- get customer info for convenience -->
                <service-call name="vsf.CustomerServices.get#CustomerInfo" out-map="customerInfo" />
            </if>
        </actions>
    </service>

    <service verb="get" noun="CustomerInfo">
        <implements service="vsf.CustomerServices.interface#CustomerInfo" />
        <actions>
            <!-- NOTE: use the web session for attributes such as customerPartyId for security; this won't work in a stateless mode or outside a web session -->
            <set field="sessionAttributes" from="ec.web.sessionAttributes" />

            <set field="userId" from="ec.user.userId" />
            <set field="partyId" from="ec.user.userAccount?.partyId ?: sessionAttributes.customerPartyId" />
            <if condition="!partyId">
                <return message="Your session has expired. Please login." />
            </if>

            <!-- TODO: handle Organization type parties, use more liberal view-entity and support 'organizationName' instead of firstName/lastName in the UI -->
            <entity-find-one entity-name="mantle.party.PersonAndUserAccount" value-field="personAndUserAccount" />
            <script>
                customerMap = [
                    username: personAndUserAccount?.username,
                    emailAddress: personAndUserAccount?.emailAddress,
                    firstName: personAndUserAccount?.firstName,
                    middleName: personAndUserAccount?.middleName,
                    lastName: personAndUserAccount?.lastName,
                    gender: personAndUserAccount?.gender
                ]
            </script>
            <script>context.putAll(customerMap)</script>

            <!-- <service-call name="mantle.party.ContactServices.get#PartyContactInfo" in-map="[partyId:partyId, telecomContactMechPurposeId: 'PhonePrimary', emailContactMechPurposeId:'EmailPrimary']" out-map="context" /> -->
        </actions>
    </service>

    <service verb="update" noun="Customer">
        <implements service="vsf.CustomerServices.interface#CustomerInfo" />
        <in-parameters>
            <parameter name="firstName" />
            <parameter name="middleName" />
            <parameter name="lastName" />
            <parameter name="gender" />
        </in-parameters>
        <actions>
            <!-- NOTE: use the web session for attributes such as customerPartyId for security; this won't work in a stateless mode or outside a web session -->
            <set field="sessionAttributes" from="ec.web.sessionAttributes" />

            <set field="userId" from="ec.user.userId" />
            <set field="partyId" from="ec.user.userAccount?.partyId ?: sessionAttributes.customerPartyId" />
            <if condition="!userId">
                <return message="Your session has expired. Please login." />
            </if>

            <service-call name="mantle.party.PartyServices.update#Account" in-map="context" />
            <service-call name="vsf.CustomerServices.get#CustomerInfo" out-map="context" />
        </actions>
    </service>

    <service verb="update" noun="CustomerPassword">
        <implements service="vsf.CustomerServices.interface#CustomerInfo" />
        <in-parameters>
            <parameter name="username" />
            <parameter name="oldPassword" />
            <parameter name="newPassword" />
            <parameter name="newPasswordVerify" default="newPassword" />
        </in-parameters>
        <actions>
            <!-- NOTE: use the web session for attributes such as customerPartyId for security; this won't work in a stateless mode or outside a web session -->
            <set field="userAccount" from="ec.user?.userAccount" />
            <set field="username" from="ec.user?.userAccount?.username" />
            <if condition="!userAccount">
                <return error="true" message="Your session has expired. Please login." />
            </if>

            <!-- NOTE: Verification happens in org.moqui.impl.UserServices.update#Password, but returns a public message and not an error.. so workaround for now?  -->
            <script>
                def token = new org.apache.shiro.authc.UsernamePasswordToken((String) userAccount.username, (String) oldPassword)
                def info = new org.apache.shiro.authc.SimpleAuthenticationInfo(userAccount.username, userAccount.currentPassword,
                        userAccount.passwordSalt ? new org.apache.shiro.util.SimpleByteSource((String) userAccount.passwordSalt) : null, "moquiRealm")
            </script>
            <if condition="!userAccount.currentPassword || !ec.ecfi.getCredentialsMatcher(userAccount.passwordHashType, 'Y'.equals(userAccount.passwordBase64)).doCredentialsMatch(token, info)">
                <if condition="userAccount.resetPassword">
                    <then>
                        <!-- try the resetPassword -->
                        <script>
                        info = new org.apache.shiro.authc.SimpleAuthenticationInfo(userAccount.username, userAccount.resetPassword,
                                userAccount.passwordSalt ? new org.apache.shiro.util.SimpleByteSource((String) userAccount.passwordSalt) : null, "moquiRealm")
                    </script>
                        <if condition="!ec.ecfi.getCredentialsMatcher(userAccount.passwordHashType, 'Y'.equals(userAccount.passwordBase64)).doCredentialsMatch(token, info)">
                            <return error="true" message="Password did not match current password or reset password for user ${username}" />
                        </if>
                    </then>
                    <else>
                        <return error="true" message="Password incorrect for user ${username}" />
                    </else>
                </if>
            </if>
            <service-call name="org.moqui.impl.UserServices.update#Password" in-map="context" />

            <!-- get customer info for convenience -->
            <service-call name="vsf.CustomerServices.get#CustomerInfo" out-map="context" />
        </actions>
    </service>

    <service verb="reset" noun="Password" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="productStoreId" required="true" />
            <parameter name="email" />
            <!-- <parameter name="bodyParameters" type="Map" default="[:]" />
            <parameter name="emailTemplateId" default-value="VSF_PASSWORD_RESET" /> -->
        </in-parameters>
        <actions>
            <service-call name="vsf.UtilServices.get#LocaleFromCookies" out-map="context" />

            <!-- TODO make sure email is for consumer (ecommerce user) to avoid resetting moqui users  -->
            <!-- <service-call name="org.moqui.impl.UserServices.reset#Password" in-map="[username: email]" out-map="response" /> -->

            <!-- find by emailAddress in case it was entered instead of username -->
            <entity-find-one entity-name="moqui.security.UserAccount" value-field="userAccount" for-update="true">
                <field-map field-name="emailAddress" from="email" />
            </entity-find-one>

            <if condition="userAccount == null">
                <!-- Fail silently to avoid disclosing user emails -->
                <return />
            </if>

            <!-- reset the password to a random value -->
            <set field="resetPassword" from="getRandomString(36)" />
            <set field="passwordNode" from="ec.ecfi.confXmlRoot.first('user-facade').first('password')" />
            <set field="userAccount.resetPassword" from="ec.ecfi.getSimpleHash(resetPassword, userAccount.passwordSalt, userAccount.passwordHashType, 'Y'.equals(userAccount.passwordBase64))" />
            <set field="userAccount.requirePasswordChange" from="(passwordNode.attribute('email-require-change') == 'true') ? 'Y' : 'N'" />
            <entity-update value-field="userAccount" />

            <!-- send an email with the new password -->
            <service-call name="vsf.CustomerServices.send#PasswordResetEmail" in-map="[productStoreId:productStoreId, userAccount:userAccount, resetPassword:resetPassword, toAddresses: email, locale:locale]" async="true" />

        </actions>
    </service>

    <service verb="send" noun="PasswordResetEmail" authenticate="anonymous-view">
        <in-parameters>
            <parameter name="productStoreId" required="true" />
            <parameter name="userAccount" type="EntityValue" required="true" />
            <parameter name="resetPassword" required="true" />
            <parameter name="toAddresses" required="true" />
            <parameter name="emailTypeEnumId" default-value="PsetResetPassword" />
            <parameter name="locale" />
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore">
                <field-map field-name="productStoreId" />
            </entity-find-one>
            <entity-find entity-name="mantle.product.store.ProductStoreEmail" list="storeEmailList">
                <date-filter />
                <econdition field-name="productStoreId" />
                <econdition field-name="emailTypeEnumId" />
            </entity-find>
            <if condition="storeEmailList">
                <!-- send email for each configured -->
                <iterate list="storeEmailList" entry="storeEmail">
                    <if condition="!storeEmail.emailTemplateId">
                        <continue />
                    </if>
                    <set field="bccAddresses" from="storeEmail?.template?.bccAddresses?:null" />
                    <set field="toUserId" from="userAccount.userId" />

                    <!-- simple bodyParameters, let the screen do data prep -->
                    <set field="bodyParameters" from="[userAccount:userAccount, productStore:productStore, resetPassword:resetPassword, locale:locale, headerImagePath:storeEmail.headerImagePath,storeDomain:productStore.storeDomain,profileUrlPath:productStore.profileUrlPath]" />

                    <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" out-map="sendOut" out-map-add-to-existing="false" in-map="[emailTemplateId:storeEmail.emailTemplateId, emailTypeEnumId:emailTypeEnumId, toAddresses:toAddresses,bccAddresses:bccAddresses, bodyParameters:bodyParameters, toUserId:toUserId]" />
                    <message>Email sent to ${toAddresses}${sendOut.emailMessageId ? ', message ID ' + sendOut.emailMessageId : ''}</message>
                </iterate>
            </if>
        </actions>
    </service>

    <service verb="set" noun="CustomerPassword" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="token" required="true" />
            <parameter name="email" required="true" />
            <parameter name="newPassword" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="updateSuccessful" type="Boolean" />
            <parameter name="passwordIssues" type="Boolean" />
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.security.UserAccount" value-field="userAccount">
                <field-map field-name="emailAddress" from="email" />
            </entity-find-one>
            <if condition="userAccount">
                <set field="username" from="userAccount.username" />
                <else>
                    <set field="username" from="email" />
                </else>
            </if>
            <set field="oldPassword" from="token" />
            <set field="newPasswordVerify" from="newPassword" />
            <service-call name="org.moqui.impl.UserServices.update#Password" in-map="context" out-map="context" />
        </actions>
    </service>

    <service verb="get" noun="ShippingAddresses">
        <implements service="vsf.CustomerServices.interface#CustomerAddressInfo" />
        <actions>
            <!-- get locale -->
            <service-call name="vsf.UtilServices.get#LocaleFromCookies" out-map="context" />
            <set field="sessionAttributes" from="ec.web.sessionAttributes" />
            <set field="partyId" from="ec.user.userAccount?.partyId ?: sessionAttributes.customerPartyId" />
            <if condition="!partyId">
                <return error="true" message="Your session has expired. Please log in." />
            </if>

            <service-call name="mantle.party.ContactServices.get#PartyContactInfoList" out-map="shippingContactListInfo" in-map="[partyId:partyId, postalContactMechPurposeId:'PostalShippingDest']" />

            <set field="postalAddressList" from="[]" />
            <iterate list="shippingContactListInfo.postalAddressList" entry="postalAddress">
                <set field="cityGeo" from="postalAddress?.postalAddress?.cityGeo" />
                <set field="stateGeo" from="postalAddress?.postalAddressStateGeo" />
                <set field="countryGeo" from="postalAddress?.postalAddressCountryGeo" />

                <script>
                    postalAddressList.add([
                        addressId: postalAddress?.postalContactMechId,
                        alias: postalAddress?.postalAddress?.attnName,
                        address1: postalAddress?.postalAddress?.address1,
                        address2: postalAddress?.postalAddress?.address2,
                        postalCode: postalAddress?.postalAddress?.postalCode,
                        city: postalAddress?.postalAddress?.city,
                        stateId: postalAddress?.postalAddressStateGeo?.geoId,
                        countryId: postalAddress?.postalAddress?.countryGeoId,
                        cityId: postalAddress?.postalAddress?.cityGeoId,
                        cityName: locale=='ar'?(cityGeo?.geoNameLocal):cityGeo?.geoName,
                        stateName: locale=='ar'?(stateGeo?.geoNameLocal):stateGeo?.geoName,
                        countryName: locale=='ar'?(countryGeo?.geoNameLocal):countryGeo?.geoName,
                        phone: postalAddress?.telecomNumber
                    ])
                </script>
            </iterate>
        </actions>
    </service>

    <service verb="create" noun="ShippingAddress">
        <implements service="vsf.CustomerServices.interface#CustomerAddressInfo" />
        <in-parameters>
            <parameter name="alias" />
            <parameter name="address1" />
            <parameter name="address2" />
            <parameter name="postalCode" />
            <parameter name="city" />
            <parameter name="cityId" />
            <parameter name="stateId" />
            <parameter name="countryId" />
            <parameter name="countryCode">
                <text-digits />
            </parameter>
            <parameter name="areaCode">
                <text-digits />
            </parameter>
            <parameter name="contactNumber">
                <matches regexp="^\d\d[-\. \d]*\d\d$" message="Please enter a valid phone number" />
            </parameter>
        </in-parameters>
        <actions>
            <!-- Verify customer is logged in -->
            <set field="sessionAttributes" from="ec.web.sessionAttributes" />
            <set field="partyId" from="ec.user.userAccount?.partyId ?: sessionAttributes.customerPartyId" />
            <if condition="!partyId">
                <return error="true" message="Your session has expired. Please log in." />
            </if>

            <!-- Prepare data for service call -->
            <set field="postalContactMechPurposeId" value="PostalShippingDest" />
            <set field="countryGeoId" from="countryId" />
            <set field="stateProvinceGeoId" from="stateId" />
            <set field="cityGeoId" from="cityId" />
            <set field="attnName" from="alias" />

            <!-- Store the address -->
            <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="context" out-map="context" />

            <service-call name="vsf.CustomerServices.get#ShippingAddresses" out-map="context" />
        </actions>
    </service>

    <service verb="update" noun="ShippingAddress">
        <implements service="vsf.CustomerServices.interface#CustomerAddressInfo" />
        <in-parameters>
            <parameter name="addressId" />
            <parameter name="alias" />
            <parameter name="address1" />
            <parameter name="address2" />
            <parameter name="postalCode" />
            <parameter name="city" />
            <parameter name="cityId" />
            <parameter name="stateId" />
            <parameter name="countryId" />
            <parameter name="countryCode">
                <text-digits />
            </parameter>
            <parameter name="areaCode">
                <text-digits />
            </parameter>
            <parameter name="contactNumber">
                <matches regexp="^\d\d[-\. \d]*\d\d$" message="Please enter a valid phone number" />
            </parameter>
        </in-parameters>
        <actions>
            <!-- Verify customer is logged in -->
            <set field="sessionAttributes" from="ec.web.sessionAttributes" />
            <set field="partyId" from="ec.user.userAccount?.partyId ?: sessionAttributes.customerPartyId" />
            <if condition="!partyId">
                <return error="true" message="Your session has expired. Please log in." />
            </if>

            <!-- Prepare data for service call -->
            <set field="postalContactMechPurposeId" value="PostalShippingDest" />
            <set field="postalContactMechId" from="addressId" />
            <set field="countryGeoId" from="countryId" />
            <set field="stateProvinceGeoId" from="stateId" />
            <set field="cityGeoId" from="cityId" />
            <set field="attnName" from="alias" />

            <!-- TODO: if no customerPartyId call service to create one now and set in session (no user account aka 'anonymous') -->
            <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="context" out-map="context" />

            <!-- TODO: if address verification/validation available call explicitly so customer knows of potential issues right away -->
            <service-call name="vsf.CustomerServices.get#ShippingAddresses" out-map="context" />
        </actions>
    </service>

    <service verb="delete" noun="ShippingAddress">
        <implements service="vsf.CustomerServices.interface#CustomerAddressInfo" />
        <in-parameters>
            <parameter name="addressId" />
        </in-parameters>
        <actions>
            <!-- Verify customer is logged in -->
            <set field="sessionAttributes" from="ec.web.sessionAttributes" />
            <set field="partyId" from="ec.user.userAccount?.partyId ?: sessionAttributes.customerPartyId" />
            <if condition="!partyId">
                <return error="true" message="Your session has expired. Please log in." />
            </if>
            <service-call name="mantle.party.ContactServices.delete#PartyContactMech" in-map="[contactMechId: addressId, partyId:partyId]" />
            <service-call name="vsf.CustomerServices.get#ShippingAddresses" out-map="context" />
        </actions>
    </service>

    <service verb="get" noun="CustomerOrders">
        <in-parameters>
            <parameter name="pageIndex" type="Integer" default="0" />
            <parameter name="pageSize" type="Integer" default="10" />
        </in-parameters>
        <out-parameters>
            <parameter name="orderInfoList" type="List">
                <parameter name="orderInfo" type="Map">
                    <parameter name="orderId" />
                    <parameter name="entryDate" />
                    <parameter name="placedDate" />
                    <parameter name="statusDescription" />
                    <parameter name="grandTotal" />
                    <parameter name="orderItemList" type="List">
                        <parameter name="orderItemMap">
                            <parameter name="orderItemSeqId" />
                            <parameter name="productSlug" />
                            <parameter name="productSku" />
                            <parameter name="itemDescription" />
                            <parameter name="quantity" />
                            <parameter name="unitAmount" />
                            <parameter name="isTax" type="Boolean" />
                            <parameter name="isDiscount" type="Boolean" />
                            <parameter name="isShipping" type="Boolean" />
                            <parameter name="isProduct" type="Boolean" />
                        </parameter>
                    </parameter>
                </parameter>
            </parameter>
            <parameter name="orderInfoListPageIndex" type="Integer" />
            <parameter name="orderInfoListPageSize" type="Integer" />
            <parameter name="orderInfoListPageMaxIndex" type="Integer" />
            <parameter name="orderInfoListPageRangeLow" type="Integer" />
            <parameter name="orderInfoListPageRangeHigh" type="Integer" />
            <parameter name="orderInfoListCount" type="Integer" />
        </out-parameters>
        <actions>
            <set field="sessionAttributes" from="ec.web.sessionAttributes" />
            <set field="customerPartyId" from="ec.user.userAccount?.partyId ?: sessionAttributes.customerPartyId" />
            <if condition="!customerPartyId">
                <return error="true" message="Your session has expired. Please log in." />
            </if>

            <set field="orderInfoList" from="[]" />
            <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrderList">
                <search-form-inputs paginate="true" />
                <econdition field-name="statusId" operator="not-equals" value="OrderOpen" />
                <econdition field-name="customerPartyId" />
                <select-field field-name="orderId,entryDate,placedDate,statusId,grandTotal" />
                <order-by field-name="-entryDate" />
            </entity-find>

            <set field="orderInfoListPageIndex" from="existingOrderListPageIndex" />
            <set field="orderInfoListPageSize" from="existingOrderListPageSize" />
            <set field="orderInfoListPageMaxIndex" from="existingOrderListPageMaxIndex" />
            <set field="orderInfoListPageRangeLow" from="existingOrderListPageRangeLow" />
            <set field="orderInfoListPageRangeHigh" from="existingOrderListPageRangeHigh" />
            <set field="orderInfoListCount" from="existingOrderListCount" />

            <iterate list="existingOrderList" entry="existingOrder">
                <entity-find-one entity-name="moqui.basic.StatusItem" value-field="statusItem" cache="true">
                    <field-map field-name="statusId" from="existingOrder.statusId" />
                </entity-find-one>
                <entity-find entity-name="mantle.order.OrderItem" list="orderItemListRaw" cache="true">
                    <econdition field-name="orderId" from="existingOrder.orderId" />
                </entity-find>

                <set field="discountItems" value="ItemDiscount,ItemDiscountAppease,ItemPromoDiscount,ItemCouponCredit,ItemPromptDiscount" />
                <set field="shippingItems" value="ItemShipping" />
                <set field="taxItems" value="ItemSalesTax,ItemVatTax" />
                <set field="productItems" value="ItemProduct,ItemServiceProduct,ItemAddtlFeature,ItemWarranty,ItemReplacement" />

                <set field="orderItemList" from="[]" />
                <iterate list="orderItemListRaw" entry="orderItemRaw">
                    <if condition="orderItemRaw.productId">
                        <service-call name="vsf.ProductServices.get#ProductIdentification" in-map="[productId:orderItemRaw.productId]" out-map="slugOut" out-map-add-to-existing="false" />
                    </if>
                    <script>
                        <![CDATA[ 
                            orderItemList.add([
                                orderItemSeqId: orderItemRaw.orderItemSeqId,
                                productSlug: slugOut?.productSlug,
                                productSku: slugOut?.productSku,
                                itemDescription: orderItemRaw.itemDescription,
                                quantity: orderItemRaw.quantity,
                                unitAmount: orderItemRaw.unitAmount,
                                isTax: taxItems.contains(orderItemRaw.itemTypeEnumId),  
                                isDiscount: discountItems.contains(orderItemRaw.itemTypeEnumId),  
                                isShipping: shippingItems.contains(orderItemRaw.itemTypeEnumId),  
                                isProduct: orderItemRaw.productId || productItems.contains(orderItemRaw.itemTypeEnumId) 
                            ])
                        ]]>
                    </script>
                </iterate>
                <script>                    
                    orderInfoList.add([
                        orderId : existingOrder.orderId,
                        entryDate : existingOrder.entryDate,
                        placedDate : existingOrder.placedDate,
                        statusDescription : statusItem.description,
                        grandTotal : existingOrder.grandTotal,
                        orderItemList : orderItemList
                    ])
                </script>
            </iterate>
        </actions>
    </service>

    <service verb="create" noun="ContactRequest">
        <in-parameters>
            <parameter name="firstName" />
            <parameter name="lastName" />
            <parameter name="emailAddress" />
            <parameter name="description" required="true" />
            <parameter name="countryCode">
                <text-digits />
            </parameter>
            <parameter name="areaCode">
                <text-digits />
            </parameter>
            <parameter name="contactNumber">
                <matches regexp="^\d\d[-\. \d]*\d\d$" message="Please enter a valid phone number" />
            </parameter>
        </in-parameters>
        <actions>
            <!-- Check if customer is logged in -->
            <set field="sessionAttributes" from="ec.web.sessionAttributes" />
            <set field="customerPartyId" from="ec.user.userAccount?.partyId ?: sessionAttributes.customerPartyId" />

            <!-- Note create#ContactRequestReCaptcha handles requiring a customerPartyId or firstName/lastName + email verification -->
            <service-call name="mantle.request.RequestServices.create#ContactRequestReCaptcha" in-map="context" out-map="context" />
            <log message="context ${context}" />
            <if condition="customerPartyId &amp;&amp; (countryCode &amp;&amp; areaCode &amp;&amp; contactNumber)">
                <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="[partyId:customerPartyId, countryCode:countryCode, areaCode:areaCode, contactNumber:contactNumber, telecomContactMechPurposeId:'PhonePrimary']" out-map="context" />
            </if>
        </actions>
    </service>

    <service verb="create" noun="CustomSalesRequest">
        <in-parameters>
            <parameter name="firstName" />
            <parameter name="lastName" />
            <parameter name="emailAddress" />
            <parameter name="description" required="true" />
            <parameter name="countryCode">
                <text-digits />
            </parameter>
            <parameter name="areaCode">
                <text-digits />
            </parameter>
            <parameter name="contactNumber">
                <matches regexp="^\d\d[-\. \d]*\d\d$" message="Please enter a valid phone number" />
            </parameter>
        </in-parameters>
        <actions>
            <!-- Check if customer is logged in -->
            <set field="sessionAttributes" from="ec.web.sessionAttributes" />
            <set field="customerPartyId" from="ec.user.userAccount?.partyId ?: sessionAttributes.customerPartyId" />

            <!-- Note create#ContactRequestReCaptcha handles requiring a customerPartyId or firstName/lastName + email verification -->
            <service-call name="mantle.request.RequestServices.create#ContactRequestReCaptcha" in-map="context" out-map="context" />
            <if condition="customerPartyId &amp;&amp; (countryCode &amp;&amp; areaCode &amp;&amp; contactNumber)">
                <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="[partyId:customerPartyId, countryCode:countryCode, areaCode:areaCode, contactNumber:contactNumber, telecomContactMechPurposeId:'PhonePrimary']" out-map="context" />
            </if>
        </actions>
    </service>

    <service verb="create" noun="CustomerRFQ">
        <in-parameters>
            <parameter name="statusId" default-value="ReqSubmitted" />
            <parameter name="priority" type="Long" default="3" />
            <parameter name="requestTypeEnumId" default-value="RqtQuote" />
            <parameter name="requestResolutionEnumId" default-value="RrUnresolved" />
            <parameter name="requestDate" default="ec.user.nowTimestamp" />
            <parameter name="productStoreId" />
            <parameter name="requestName" />
            <parameter name="description" required="true" />

            <parameter name="filedByPartyId" default="ec.user.userAccount?.partyId" />
            <parameter name="customerPartyId" default="ec.user.userAccount?.partyId" />
            <parameter name="firstName" />
            <parameter name="lastName" />

            <parameter name="emailContactMechId" />
            <parameter name="emailAddress">
                <text-email />
            </parameter>
            <parameter name="countryCode">
                <text-digits />
            </parameter>
            <parameter name="areaCode">
                <text-digits />
            </parameter>
            <parameter name="contactNumber">
                <matches regexp="^\d\d[-\. \d]*\d\d$" message="Please enter a valid phone number" />
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="requestId" />
            <parameter name="customerPartyId" />
        </out-parameters>
        <actions>
            <set field="visitId" from="ec.user.visitId" />

            <if condition="!customerPartyId">
                <if condition="!firstName || !lastName || !emailAddress">
                    <message public="true" type="warning">Please enter your first name, last name, and email address</message>
                    <return error="true" message="Name or email missing" />
                </if>
                <set field="firstName" from="firstName.trim()" />

                <!-- search for existing party by email address -->
                <entity-find entity-name="mantle.party.contact.PartyContactMechInfo" list="emailPcmList">
                    <date-filter />
                    <econdition field-name="infoString" from="emailAddress" />
                </entity-find>
                <iterate list="emailPcmList" entry="emailPcm">
                    <entity-find-one entity-name="mantle.party.PartyDetail" value-field="party">
                        <field-map field-name="partyId" from="emailPcm.partyId" />
                    </entity-find-one>
                    <if condition="party.disabled == 'Y' || party.partyTypeEnumId != 'PtyPerson'">
                        <continue />
                    </if>
                    <if condition="!firstName.equalsIgnoreCase(party.firstName?.trim())">
                        <continue />
                    </if>
                    <set field="customerPartyId" from="emailPcm.partyId" />
                    <set field="emailContactMechId" from="emailPcm.contactMechId" />
                    <break />
                </iterate>

                <!-- create a party with the name -->
                <if condition="!customerPartyId">
                    <service-call name="mantle.party.PartyServices.create#Person" out-map="createPartyOut" in-map="[firstName:firstName, lastName:lastName, roleTypeId:'Customer']" />
                    <set field="customerPartyId" from="createPartyOut.partyId" />
                </if>

                <set field="filedByPartyId" from="customerPartyId" />
            </if>
            <if condition="!emailContactMechId">
                <if condition="emailAddress">
                    <then>
                        <!-- find a matching one, if none create -->
                        <set field="emailAddress" from="emailAddress.trim()" />
                        <entity-find entity-name="mantle.party.contact.PartyContactMechInfo" list="existingEmailList">
                            <date-filter />
                            <econdition field-name="partyId" from="customerPartyId" />
                            <econdition field-name="infoString" from="emailAddress" />
                        </entity-find>
                        <if condition="existingEmailList">
                            <then>
                                <set field="emailContactMechId" from="existingEmailList[0].contactMechId" />
                            </then>
                            <else>
                                <service-call name="mantle.party.ContactServices.create#EmailAddress" out-map="emailOut" in-map="[partyId:customerPartyId, emailAddress:emailAddress, contactMechPurposeId:'EmailPrimary']" />
                                <set field="emailContactMechId" from="emailOut.contactMechId" />
                            </else>
                        </if>
                    </then>
                    <else>
                        <entity-find entity-name="mantle.party.contact.PartyContactMechInfo" list="existingEmailList">
                            <date-filter />
                            <econdition field-name="partyId" from="customerPartyId" />
                            <econdition field-name="contactMechTypeEnumId" value="CmtEmailAddress" />
                        </entity-find>
                        <set field="emailContactMechId" from="existingEmailList ? existingEmailList[0].contactMechId : null" />
                    </else>
                </if>
            </if>
            <if condition="!emailContactMechId">
                <message public="true" type="warning">Please enter your email address</message>
                <return error="true" message="Email record missing" />
            </if>

            <if condition="customerPartyId &amp;&amp; (countryCode &amp;&amp; areaCode &amp;&amp; contactNumber)">
                <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="[partyId:customerPartyId, countryCode:countryCode, areaCode:areaCode, contactNumber:contactNumber, telecomContactMechPurposeId:'PhonePrimary']" out-map="context" />
            </if>

            <service-call name="create#mantle.request.Request" out-map="context" in-map="context" />
            <service-call name="create#mantle.request.RequestParty" in-map="[requestId:requestId, partyId:filedByPartyId, roleTypeId:'Reporter', fromDate:ec.user.nowTimestamp]" />
            <service-call name="create#mantle.request.RequestParty" in-map="[requestId:requestId, partyId:customerPartyId, roleTypeId:'Customer', fromDate:ec.user.nowTimestamp]" />

            <message public="true" type="success">Thank you, we have received your request. Your request number is ${requestId}</message>
        </actions>
    </service>

    <service verb="create" noun="CustomerRFQReCaptcha">
        <implements service="vsf.CustomerServices.create#CustomerRFQ" />
        <in-parameters>
            <parameter name="reCaptchaToken" />
        </in-parameters>
        <actions>
            <service-call name="org.moqui.impl.GoogleServices.verify#ReCaptcha" in-map="[reCaptchaToken:reCaptchaToken]" />
            <service-call name="vsf.CustomerServices.create#CustomerRFQ" in-map="context" out-map="context" />
        </actions>
    </service>
</services>